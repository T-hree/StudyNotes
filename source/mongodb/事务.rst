===================
事务
===================


writeConcern
=================

什么是writeConcern
----------------------

writeConcern 决定一个写操作落到多少个节点上才算成功。
writeConcern的取值包括：
- 0: 发起写操作， 不关心是否成功；
- 1: 集群最大数据节点数： 写操作需要被复制到指定节点数才算成功
- majority: 写操作需要被复制到大多数节点上才算成功
发起写操作的程序将阻塞到写操作到达指定的节点数为止

默认行为
-----------

3 节点复制集 不作任何特别设定（默认值）：

 .. image:: ../_static/mongodb/img/img_66.png
    :align: center

w: "majority"
--------------------

大多数节点确认模式

 .. image:: ../_static/mongodb/img/img_67.png
    :align: center

w: "all"
---------------------

全部节点确认模式

 .. image:: ../_static/mongodb/img/img_68.png
    :align: center

j: true
----------------

writeConcern 可以决定写操作到达多少个节点才算成功， journal则定义如何才算成功。
取值包括：
- true: 写操作落到journal文件才算成功；
- false: 写操作到达内存即算作成功。

writeConcern 的意义
-------------------------

对于5个节点的复制集来说，写落到多少个几点上才算是安全的？
- 1
- 2
- 3  √
- 4  √
- 5  √
- majority  √

writeConcern 实验
----------------------

*在复制集测试writeConcern参数*
::

    db.test.insert({count:1}, {writeConcern:{w:"majority"}})
    db.test.insert({count:1}, {writeConcern:{w:3}})
    db.test.insert({count:1}, {writeConcern:{w:4}})

*配置延迟节点， 模拟网络延迟（复制延迟）*
::

    conf=rs.conf()
    conf.members[2].secondaryDelaySecs = 10 （延迟节点  单位秒）
    conf.members[2].priority = 0
    rs.reconfig(conf)

*观察复制集延迟下的写入， 以及timeout参数*
::

    db.test.insert({count:1},{writeConcern:{w:3}})
    # 等待10秒后 返回结果 写入完成
    db.test.insert({count:1},{writeConcern:{w:3, wtimeout:3000}})
    # 等待3秒后， 返回结果：
    WriteResult({
            "nInserted" : 1,
            "writeConcernError" : {
                    "code" : 64,
                    "codeName" : "WriteConcernFailed",
                    "errmsg" : "waiting for replication timed out",
                    "errInfo" : {
                            "wtimeout" : true,
                            "writeConcern" : {
                                    "w" : 3,
                                    "wtimeout" : 3000,
                                    "provenance" : "clientSupplied"
                            }
                    }
            }
    })
    # "nInserted" : 1,表示 写入成功了， 后面的error 表示  某些节点还没有完成  需要更新义务场景进行处理

注意事项
-----------------

- 虽然多于半数的writeConcern 都是安全的， 但通常只会设置majority， 因为这是等待些人延迟时间最短的选择；
- 不要设置 writeConcern 等于总节点数， 因为一旦有一个节点故障， 所有写操作都将失败；
- writeConcern 虽然会增加 写操作延迟时间， 但并不会显著增加集群压力， 应此无论是否等待，写操作最终都会复制到所有节点上。 设置writConcern只是让写操作等待复制后在返回而已；
- 应对重要数据 应用 `` {w:"majority"}`` 普通数据可以应用 ``{w:1}`` 以确保最佳性能


读事务
===============

综述
-------------

在读取数据的过程中我们需要关注以下两个问题：
- 从哪里读？ 关注数据节点 位置
- 什么样的数据可以读？ 关注数据的隔离性
| 第一个问题是由readPreference来解决
| 第二个问题则是由 readConcern来解决


什么是readPreference
---------------------------

readPreference决定使用哪一个节点来满足正在发起的读请求。可选值包括：
- primary: 只选择主节点
- primaryPreferred： 优先选择主节点， 如果不可用则选择从节点
- secondary: 只选择从节点；
- secondaryPreferred: 优先选择从节点，如果从节点不可用则选择主节点
- nearest: 选择最近的节点

readPreference场景举例
----------------------------

- 用户下订单马上将用户订单详情页 ---- primary/primaryPreferred. 因为此时从节点可能还没有复制到新订单
- 用户查询自己下过的订单 ---- secondary/secondaryPreferred. 查询历史订单对时效性通常没有太高的要求
- 生成报表 ---- secondary 报表对是时效性要求不搞， 但资源需求大， 可以在从节点单独处理， 避免对线上用户造成影响
- 将用户上传的图片分发到全世界， 让各地用户能够就近读取 ---- nearest  每个地区的应用选择最近的节点读取数据


readPreference 与 Tag
-------------------------------

readPreference只能控制使用一类节点。Tag则可以将节点选择控制到一个或多个节点。考虑一下场景：
- 一个  5个节点的复制集
- 3个节点硬件较好， 专用于服务线上客户
- 2个节点硬件较差， 专用于生成报表
可以使用Tag来打到这样的控制目的：
- 为3个较好的节点打上 {purpose:"online"}
- 为2个较差的节点打上 {purpose: "analyse"}
- 在线应用读取时指定 online, 报表读取时指定 analyse


readPreference 配置
-----------------------

通过MongoDB的连接串参数：
::

    mongodb://host1:27017,host2:27017,host3:27017/?replicaSet=rs#readPreference=secondary


通过MongoDB驱动程序API：
::

    MongodbCollection.withReadPreference(ReadPreference readPref)

Mongo Shell:
::

    db.collection.find({}).readPref("secondary")

readPreference实验：从节点读
-----------------------------------
- 主节点写入{x:1}, 观察该条数据在各个节点均可见
- 在两个从节点分别执行db.fsyncLock() 来锁定写入(同步)
- 主节点写入{x:2}
    - db.test.find({a:123})
    - db.test.find({a:123}).readPref("secondary")  # 指定在从节点读
- 解除从节点锁定db.fsyncUnlock()
    - db.test.find({a:123}).readPref("secondary")

注意事项
-------------------

- 指定readPreference时也应注意高可用的问题。 例如将readPreference指定primary， 则发生故障转移不存在primary期间将没有节点可读。如果业务允许， 则应选择primaryPreferred
- 使用Tag是也会遇到同样的问题， 如果只有一个节点拥有一个特定Tag， 则在这个节点失效时 将无节点可读。 这在有时候是期望的结果， 有时候不是。例如：
    - 如果报表使用的节点失效， 即使不生成报表， 通常也不希望将报表负载转移到其他节点上，此时只有一个节点有报表Tag是合理的选择
    - 如果线上节点失效， 通常希望有代替节点， 所以因该保持多个节点有同样的Tag
- Tag 有事需要与优先级、 选举权综合考虑， 例如做报表的节点通常不会希望他成为主节点， 则优先级因为0